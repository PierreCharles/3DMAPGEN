package model.mesh;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.Iterator;
import java.util.TreeMap;

import config.Config;
import gnu.trove.map.TLongIntMap;
import gnu.trove.map.hash.TLongIntHashMap;
import javafx.scene.shape.TriangleMesh;
import javafx.scene.shape.VertexFormat;
import wblut.hemesh.HE_Face;
import wblut.hemesh.HE_Halfedge;
import wblut.hemesh.HE_Mesh;
import wblut.hemesh.HE_Vertex;

/**
 * Class Mesh A meshing is a set of geometric forms arranged so as to model
 * objects.It is constituted by summits, connected some to the others by faces.
 * When all Faces are triangles, we speak of triangular meshing Trimesh, or of
 * triangulation according to them Domains.
 * 
 * @author picharles
 */
public class MapMesh {

	private TreeMap<Double, TreeMap<Double, Point3D>> setOfMapMeshVertices, setOfMapMeshVerticesBase;
	private TriangleMesh triangleMapMesh;
	private double mapMeshHeight, mapMeshWidth;
	private String mapMeshName;
	private int mapMeshID;
	private static int Map_Mesh_Counter = 1;
	private static final int DEFAULT_MAP_MESH_COUNTER = 1;
	private HE_Mesh he_mesh;


	/**
	 * Constructor af a Mesh
	 */
	public MapMesh(double mapHeight, double mapWidth) {

		this.mapMeshHeight = mapHeight;
		this.mapMeshWidth = mapWidth;

		this.mapMeshID = Map_Mesh_Counter++;
		this.mapMeshName = Config.EXPORT_PREFIX_FILE_NAME + this.mapMeshID;

		triangleMapMesh = new TriangleMesh(VertexFormat.POINT_TEXCOORD);
		triangleMapMesh.getTexCoords().addAll(0, 0);

		setOfMapMeshVertices = new TreeMap<Double, TreeMap<Double, Point3D>>();
		setOfMapMeshVerticesBase = new TreeMap<Double, TreeMap<Double, Point3D>>();

		Config.Debug("Création d'une MapMesh: " + mapMeshName + " -> H: " + mapMeshHeight + " W: " + mapMeshWidth);
	}


	/**
	 * Method to get the HE_Mesh object
	 * 
	 * @return HE_Mesh object
	 */
	public HE_Mesh getHe_mesh() {
		return he_mesh;
	}

	/**
	 * Setter of the HE_Mesh object of the current partel map
	 * 
	 * @param he_mesh
	 */
	public void setHe_mesh(HE_Mesh he_mesh) {
		this.he_mesh = he_mesh;
	}

	/**
	 * Method to generate a 3D object for the 3D Viewer
	 */
	public void generate3DObject() {
		// TODO NOT IMPLETED YET
	}

	/**
	 * Static method to reset the mesh counter
	 */
	public static void resetMapMeshCounter() {
		Map_Mesh_Counter = DEFAULT_MAP_MESH_COUNTER;
	}

	/**
	 * Method to export a MeshMap object file This algorithme is based on this
	 * static function HET_Export.saveToOBJNN(this.he_mesh, destination,
	 * this.mapMeshName);
	 * This methode do not export normal vector
	 * 
	 * @param destination
	 */
	public void exportMapMeshToObj(String destination) {

		OutputStream objStream = null;
		PrintWriter objWriter = null;
		final TLongIntMap keyToIndex = new TLongIntHashMap(10, 0.5f, -1L, -1);
		
		try {
			objStream = new FileOutputStream(new File(destination, this.mapMeshName + ".obj"));
			objWriter = new PrintWriter(objStream);
			objWriter.println("# generated by 3DMapGen and HET_OBJWriter");
		} catch (final Exception e) {
			e.printStackTrace();
		}
	
		exportMeshVertices(objWriter, keyToIndex);
		exportMeshFaces(objWriter, keyToIndex);

		try {
			objWriter.flush();
			objWriter.close();
			objStream.flush();
			objStream.close();
		} catch (final IOException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Methode to write mesh vertcices in objWritter
	 */
	private void exportMeshVertices(PrintWriter objWriter, TLongIntMap keyToIndex) {
		final Iterator<HE_Vertex> vItr = he_mesh.vItr();
		HE_Vertex v;
		int i = 0;
		while (vItr.hasNext()) {
			v = vItr.next();
			keyToIndex.put(v.key(), i++);
			objWriter.println("v " + v.xd() + " " + v.yd() + " " + v.zd());
		}
	}

	/**
	 * Methode to write mesh faces in objWritter
	 */
	private void exportMeshFaces(PrintWriter objWriter, TLongIntMap keyToIndex) {
		final Iterator<HE_Face> fItr = he_mesh.fItr();
		HE_Face f;
		HE_Halfedge he;
		while (fItr.hasNext()) {
			f = fItr.next();
			he = f.getHalfedge();
			final int n = f.getFaceOrder();
			final int[] indices = new int[n];
			for (int i = 0; i < n; i++) {
				indices[i] = keyToIndex.get(he.getVertex().key()) + 1;
				he = he.getNextInFace();
			}
			objWriter.print("f ");
			for (int i = 0; i < indices.length - 1; i++) {
				objWriter.print(indices[i] + " ");
			}
			objWriter.println(indices[indices.length - 1]);
		}
	}

	/**
	 * Getter of the parcel name
	 * 
	 * @return the parcel name : String
	 */
	public String getMapMeshName() {
		return mapMeshName;
	}

	/**
	 * Getter of the parcel map mesh ID
	 * 
	 * @return the parcel id : an integer
	 */
	public int getMapMeshID() {
		return mapMeshID;
	}

	/**
	 * Setter of the parcel mesh name
	 * 
	 * @param parcelName
	 *            : string
	 */
	public void setMapMeshName(String meshName) {
		this.mapMeshName = meshName;
	}

	/**
	 * Getter of the map height
	 * 
	 * @return the map height
	 */
	public double getMapMeshHeight() {
		return mapMeshHeight;
	}

	/**
	 * Getter of the map width
	 * 
	 * @return the map width
	 */
	public double getMapMeshWidth() {
		return mapMeshWidth;
	}

	/**
	 * Getter of the triangle map mesh
	 * 
	 * @return the triangle map mesh : TriangleMesh
	 */
	public TriangleMesh getTriangleMapMesh() {
		return triangleMapMesh;
	}

	/**
	 * Method to set the height of the map
	 * 
	 * @param mapMeshHeight
	 *            : double
	 */
	public void setMapMeshHeight(double mapMeshHeight) {
		this.mapMeshHeight = mapMeshHeight;
	}

	/**
	 * Method to set the width of the map
	 * 
	 * @param mapMeshWidth
	 *            : double
	 */
	public void setMapMeshWidth(double mapMeshWidth) {
		this.mapMeshWidth = mapMeshWidth;
	}

	/**
	 * Getter of a set of vertices
	 * 
	 * @return a tree map of set of vertices
	 */
	public TreeMap getSetOfVertices() {
		return setOfMapMeshVertices;
	}

	/**
	 * Getter of set of vertices base
	 * 
	 * @return a tree map of set of vertices base
	 */
	public TreeMap getSetOfVerticesBase() {
		return setOfMapMeshVerticesBase;
	}

	/**
	 * To string override method
	 * 
	 * @return string
	 */
	@Override
	public String toString() {
		return Config.EXPORT_PREFIX_FILE_NAME + mapMeshID;
	}

	/**
	 * Method to add a vertices into the tree map of set of vertices
	 * 
	 * @param line
	 * @param column
	 * @param wb_coords
	 */
	public void addVertices(double line, double column, Point3D wb_coords) {
		if (!this.setOfMapMeshVertices.containsKey(line)) {
			this.setOfMapMeshVertices.put(line, new TreeMap<Double, Point3D>());
		}
		this.setOfMapMeshVertices.get(line).put(column, wb_coords);
	}

	/**
	 * Method to add a vertices base into the tree map of set of vertices base
	 * 
	 * @param line
	 * @param column
	 * @param vertices
	 */
	public void addVerticesBase(double line, double column, Point3D wb_coords) {
		if (!this.setOfMapMeshVerticesBase.containsKey(line)) {
			this.setOfMapMeshVerticesBase.put(line, new TreeMap<Double, Point3D>());
		}
		this.setOfMapMeshVerticesBase.get(line).put(column, wb_coords);
	}

	/**
	 * Method to get a surface point
	 * 
	 * @param line
	 * @param column
	 * @return the vertices (or null)
	 */
	public Point3D getSurfacePoint(double line, double column) {
		if (getSetOfVertices().containsKey(line)) {
			TreeMap verticesTreeMap = (TreeMap) getSetOfVertices().get(line);
			if (verticesTreeMap.containsKey(column)) {
				return (Point3D) verticesTreeMap.get(column);
			}
		}
		return null;
	}

	/**
	 * Method to get a base point
	 * 
	 * @param line
	 * @param column
	 * @return a vertices (or null)
	 */
	public Point3D getBasePoint(double line, double column) {
		if (getSetOfVerticesBase().containsKey(line)) {
			TreeMap sommetTreeMap = (TreeMap) getSetOfVerticesBase().get(line);
			if (sommetTreeMap.containsKey(column)) {
				return (Point3D) sommetTreeMap.get(column);
			}
		}
		return null;
	}
}
