package model.mesh;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.Iterator;
import java.util.TreeMap;

import config.Config;
import gnu.trove.map.TLongIntMap;
import gnu.trove.map.hash.TLongIntHashMap;
import wblut.hemesh.HE_Face;
import wblut.hemesh.HE_Halfedge;
import wblut.hemesh.HE_Mesh;
import wblut.hemesh.HE_Vertex;

/**
 * Class Mesh A meshing is a set of geometric forms arranged so as to model
 * objects.It is constituted by summits, connected some to the others by faces.
 * When all Faces are triangles, we speak of triangular meshing Trimesh, or of
 * triangulation according to them Domains.
 * 
 * @author picharles
 */
public class MapMesh {

	private TreeMap<Double, TreeMap<Double, Point3D>> setOfSurfacePoints, setOfBasePoints, setOfBaseRaisedPoints, setOfBaseRaisedSidePoints;
	private String mapMeshName;
	private int mapMeshID;
	private static int Map_Mesh_Counter = 1;
	private static final int DEFAULT_MAP_MESH_COUNTER = 1;
	private HE_Mesh he_mesh;

	/**
	 * Constructor af a Mesh
	 */
	public MapMesh(double mapHeight, double mapWidth) {

		this.mapMeshID = Map_Mesh_Counter++;
		this.mapMeshName = Config.EXPORT_PREFIX_FILE_NAME + this.mapMeshID;

		setOfSurfacePoints = new TreeMap<Double, TreeMap<Double, Point3D>>();
		setOfBasePoints = new TreeMap<Double, TreeMap<Double, Point3D>>();
		setOfBaseRaisedPoints = new TreeMap<Double, TreeMap<Double, Point3D>>();
		setOfBaseRaisedSidePoints = new TreeMap<Double, TreeMap<Double, Point3D>>();

		Config.Debug("Création d'une MapMesh: " + mapMeshName + " -> H: " + mapHeight + " W: " + mapWidth);
	}


	/**
	 * Methode to export a MeshMap object file This algorithme is based on this
	 * static function HET_Export.saveToOBJNN(this.he_mesh, destination,
	 * this.mapMeshName);
	 * This methode do not export normal vector
	 * 
	 * @param destination
	 */
	public void exportMapMeshToObj(String destination) {

		OutputStream objStream = null;
		PrintWriter objWriter = null;
		final TLongIntMap keyToIndex = new TLongIntHashMap(10, 0.5f, -1L, -1);
		
		try {
			objStream = new FileOutputStream(new File(destination, this.mapMeshName + ".obj"));
			objWriter = new PrintWriter(objStream);
			objWriter.println("# generated by 3DMapGen and HET_OBJWriter");
		} catch (final Exception e) {
			e.printStackTrace();
		}
	
		exportMeshVertices(objWriter, keyToIndex);
		exportMeshFaces(objWriter, keyToIndex);

		try {
			objWriter.flush();
			objWriter.close();
			objStream.flush();
			objStream.close();
		} catch (final IOException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Methode to write mesh vertcices in objWritter
	 */
	private void exportMeshVertices(PrintWriter objWriter, TLongIntMap keyToIndex) {
		final Iterator<HE_Vertex> vItr = he_mesh.vItr();
		HE_Vertex v;
		int i = 0;
		while (vItr.hasNext()) {
			v = vItr.next();
			keyToIndex.put(v.key(), i++);
			objWriter.println("v " + v.xd() + " " + v.yd() + " " + v.zd());
		}
	}

	/**
	 * Methode to write mesh faces in objWritter
	 */
	private void exportMeshFaces(PrintWriter objWriter, TLongIntMap keyToIndex) {
		final Iterator<HE_Face> fItr = he_mesh.fItr();
		HE_Face f;
		HE_Halfedge he;
		while (fItr.hasNext()) {
			f = fItr.next();
			he = f.getHalfedge();
			final int n = f.getFaceOrder();
			final int[] indices = new int[n];
			for (int i = 0; i < n; i++) {
				indices[i] = keyToIndex.get(he.getVertex().key()) + 1;
				he = he.getNextInFace();
			}
			objWriter.print("f ");
			for (int i = 0; i < indices.length - 1; i++) {
				objWriter.print(indices[i] + " ");
			}
			objWriter.println(indices[indices.length - 1]);
		}
	}
	
	/**
	 * Method to get the HE_Mesh object
	 * 
	 * @return HE_Mesh object
	 */
	public HE_Mesh getHe_mesh() {
		return he_mesh;
	}

	/**
	 * Setter of the HE_Mesh object of the current partel map
	 * 
	 * @param he_mesh
	 */
	public void setHe_mesh(HE_Mesh he_mesh) {
		this.he_mesh = he_mesh;
	}

	/**
	 * Getter of the parcel name
	 * 
	 * @return the parcel name : String
	 */
	public String getMapMeshName() {
		return mapMeshName;
	}

	/**
	 * To string override method
	 * 
	 * @return string
	 */
	@Override
	public String toString() {
		return Config.EXPORT_PREFIX_FILE_NAME + mapMeshID;
	}

	/**
	 * Static method to reset the mesh counter
	 */
	public static void resetMapMeshCounter() {
		Map_Mesh_Counter = DEFAULT_MAP_MESH_COUNTER;
	}

	/**
	 * Methode to add a point into the tree map of set of vertices
	 * 
	 * @param line
	 * @param column
	 * @param Point 3D
	 */
	public void addSurfacePoint(double line, double column, Point3D wb_coords) {
		addPoint(setOfSurfacePoints, line, column, wb_coords);
	}

	/**
	 * Methode to add a point base into the tree map of set of vertices base
	 * 
	 * @param line
	 * @param column
	 * @param Point 3D
	 */
	public void addBasePoint(double line, double column, Point3D wb_coords) {
		addPoint(setOfBasePoints, line, column, wb_coords);
	}
	
	/**
	 * Methode to add a point base raised into the tree map of set of vertices base
	 * 
	 * @param line
	 * @param column
	 * @param Point 3D
	 */
	public void addBaseRaisedPoint(double line, double column, Point3D wb_coords) {	
		addPoint(setOfBaseRaisedPoints, line, column, wb_coords);
	}
	
	
	/**
	 * Methode to add a point base side raised into the tree map of set of vertices base
	 * 
	 * @param line
	 * @param column
	 * @param Point 3D
	 */
	public void addBaseRaisedSidePoint(double line, double column, Point3D wb_coords) {	
		addPoint(setOfBaseRaisedSidePoints, line, column, wb_coords);
	}
	
	
	/**
	 * Methode to get a surface point
	 * 
	 * @param line
	 * @param column
	 * @return the 3D Point (or null)
	 */
	public Point3D getSurfacePoint(double line, double column) {
		return getPoint(setOfSurfacePoints, line, column);
	}

	/**
	 * Methode to get a base point
	 * 
	 * @param line
	 * @param column
	 * @return a 3D Point (or null)
	 */
	public Point3D getBasePoint(double line, double column) {
		return getPoint(setOfBasePoints, line, column);
	}
	
	
	/**
	 * Methode to get a base raised point
	 * 
	 * @param line
	 * @param column
	 * @return a 3D Point (or null)
	 */
	public Point3D getBaseRaisedPoint(double line, double column) {
		return getPoint(setOfBaseRaisedPoints, line, column);
	}

	
	/**
	 * Methode to get a base raised side point
	 * 
	 * @param line
	 * @param column
	 * @return a 3D Point (or null)
	 */
	public Point3D getBaseRaisedSidePoint(double line, double column) {
		return getPoint(setOfBaseRaisedSidePoints, line, column);
	}
	
	
	/**
	 * Generic Methode to add a point base raised into the tree map of set of vertices base
	 * 
	 * @param line
	 * @param column
	 * @param Point 3D
	 */
	private void addPoint(TreeMap<Double, TreeMap<Double, Point3D>> treeMap, double line, double column, Point3D wb_coords) {
		if (!treeMap.containsKey(line)) {
			treeMap.put(line, new TreeMap<Double, Point3D>());
		}
		treeMap.get(line).put(column, wb_coords);
	}
	
	/**
	 * Generic Methode to get a point
	 * 
	 * @param line
	 * @param column
	 * @return Point 3D (or null)
	 */
	public Point3D getPoint(TreeMap<Double, TreeMap<Double, Point3D>> treeMap, double line, double column) {
		if (treeMap.containsKey(line)) {
			TreeMap<Double, Point3D> treeMapPoint = (TreeMap<Double, Point3D>) treeMap.get(line);
			if (treeMapPoint.containsKey(column)) {
				return (Point3D) treeMapPoint.get(column);
			}
		}
		return null;
	}
}
