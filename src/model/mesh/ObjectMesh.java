package model.mesh;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.Iterator;

import gnu.trove.map.TLongIntMap;
import gnu.trove.map.hash.TLongIntHashMap;
import wblut.hemesh.HE_Face;
import wblut.hemesh.HE_Halfedge;
import wblut.hemesh.HE_Mesh;
import wblut.hemesh.HE_Vertex;

/**
 * Super class of a mesh : ObjectMesh
 * Contains all usefull methodes for mapMesh and clipMesh 
 * 
 * @author picharles
 *
 */
public class ObjectMesh {

	private HE_Mesh he_mesh;
	private String name;
	
	/**
	 * Protected constructor of an ObjectMesh
	 * 
	 * @param name : the name of the mesh
	 * @param id : the current id of the mesh
	 */
	protected ObjectMesh(String name, int id){
		this.name = name+id;
	}
	
	/**
	 * Getter of the name of the mesh
	 * 
	 * @return string : the name of the mesh
	 */
	public String getName() {
		return name;
	}

	/**
	 * Override methode toString
	 */
	@Override
	public String toString(){
		return this.name;
	}
	/**
	 * Method to get the HE_Mesh object
	 * 
	 * @return HE_Mesh object
	 */
	public HE_Mesh getHe_mesh() {
		return he_mesh;
	}

	/**
	 * Setter of the HE_Mesh object
	 * 
	 * @param he_mesh
	 */
	public void setHe_mesh(HE_Mesh he_mesh) {
		this.he_mesh = he_mesh;
	}
	
	/**
	 * Methode to export a HE_Mesh object file. This algorithme is based on this
	 * static function HET_Export.saveToOBJNN(this.he_mesh, destination,
	 * this.mapMeshName);
	 * This methode do not export normal vector
	 * 
	 * @param destination
	 * @param name of the mesh
	 */
	public void exportMeshToObj(String destination, String meshName) {

		OutputStream objStream = null;
		PrintWriter objWriter = null;
		final TLongIntMap keyToIndex = new TLongIntHashMap(10, 0.5f, -1L, -1);
		
		try {
			objStream = new FileOutputStream(new File(destination, meshName + ".obj"));
			objWriter = new PrintWriter(objStream);
			objWriter.println("# generated by 3DMapGen and HET_OBJWriter");
		} catch (final Exception e) {
			e.printStackTrace();
		}
	
		exportMeshVertices(objWriter, keyToIndex);
		exportMeshFaces(objWriter, keyToIndex);

		try {
			objWriter.flush();
			objWriter.close();
			objStream.flush();
			objStream.close();
		} catch (final IOException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Methode to write mesh vertcices in objWritter
	 */
	private void exportMeshVertices(PrintWriter objWriter, TLongIntMap keyToIndex) {
		final Iterator<HE_Vertex> vItr = he_mesh.vItr();
		HE_Vertex v;
		int i = 0;
		while (vItr.hasNext()) {
			v = vItr.next();
			keyToIndex.put(v.key(), i++);
			objWriter.println("v " + v.xd() + " " + v.yd() + " " + v.zd());
		}
	}

	/**
	 * Methode to write mesh faces in objWritter
	 */
	private void exportMeshFaces(PrintWriter objWriter, TLongIntMap keyToIndex) {
		final Iterator<HE_Face> fItr = this.he_mesh.fItr();
		HE_Face f;
		HE_Halfedge he;
		while (fItr.hasNext()) {
			f = fItr.next();
			he = f.getHalfedge();
			final int n = f.getFaceOrder();
			final int[] indices = new int[n];
			for (int i = 0; i < n; i++) {
				indices[i] = keyToIndex.get(he.getVertex().key()) + 1;
				he = he.getNextInFace();
			}
			objWriter.print("f ");
			for (int i = 0; i < indices.length - 1; i++) {
				objWriter.print(indices[i] + " ");
			}
			objWriter.println(indices[indices.length - 1]);
		}
	}
	
}
